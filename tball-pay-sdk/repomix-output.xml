This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
examples/
  simple-payment/
    app.js
    index.html
src/
  core/
    PaymentProcessor.js
  token/
    TokenRegistry.js
  utils/
    transaction.js
    validation.js
  wallet/
    PhantomAdapter.js
  index.js
.gitignore
package.json
README.md
server.js
webpack.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="examples/simple-payment/app.js">
// Simple example app
document.addEventListener('DOMContentLoaded', async () => {
  // Initialize SDK (from your renamed UMD bundle)
  const { PaymentProcessor, PhantomAdapter } = TBallPaySDK;

  let sdk;
  try {
    // 1️⃣ Instantiate & configure
    sdk = new PaymentProcessor({ network: 'mainnet-beta' });
    sdk.setWalletAdapter(new PhantomAdapter());

    // 2️⃣ Initialize connection
    await sdk.init();

    console.log('SDK initialized successfully');
    updateStatus('SDK initialized. Please connect your wallet.');
  } catch (error) {
    console.error('Failed to initialize SDK:', error);
    updateStatus(`Error initializing: ${error.message}`, true);
    return;
  }

  // Wire up the UI
  setupEventListeners(sdk);
  populateTokenSelector(sdk);
});

function setupEventListeners(sdk) {
  const connectButton    = document.getElementById('connectWallet');
  const disconnectButton = document.getElementById('disconnectWallet');
  const sendButton       = document.getElementById('sendPayment');
  const tokenSelector    = document.getElementById('tokenSelector');

  connectButton?.addEventListener('click', async () => {
    try {
      updateStatus('Connecting wallet...');
      const wallet = await sdk.connectWallet();
      document.getElementById('walletInfo').textContent =
        `Connected: ${wallet.publicKey.toString().slice(0,8)}…${wallet.publicKey.toString().slice(-8)}`;
      updateStatus('Wallet connected successfully');

      const selectedToken = tokenSelector.value;
      const balance = await sdk.getTokenBalance(selectedToken);
      updateBalance(balance, selectedToken);
    } catch (error) {
      console.error('Connection error:', error);
      updateStatus(`Connection failed: ${error.message}`, true);
    }
  });

  disconnectButton?.addEventListener('click', async () => {
    try {
      await sdk.disconnectWallet();
      document.getElementById('walletInfo').textContent = 'Not connected';
      updateBalance(0, tokenSelector.value);
      updateStatus('Wallet disconnected');
    } catch (error) {
      console.error('Disconnection error:', error);
      updateStatus(`Disconnection failed: ${error.message}`, true);
    }
  });

  tokenSelector?.addEventListener('change', async () => {
    if (!sdk.wallet) return;
    try {
      const balance = await sdk.getTokenBalance(tokenSelector.value);
      updateBalance(balance, tokenSelector.value);
    } catch (error) {
      console.error('Error fetching balance:', error);
    }
  });

  sendButton?.addEventListener('click', async () => {
    try {
      const recipient = document.getElementById('recipient').value.trim();
      const amount    = parseFloat(document.getElementById('amount').value);
      const tokenMint = tokenSelector.value;

      if (!recipient) {
        return updateStatus('Please enter a recipient address', true);
      }
      if (isNaN(amount) || amount <= 0) {
        return updateStatus('Please enter a valid amount', true);
      }

      updateStatus('Preparing transaction...');

      if (!sdk.wallet) {
        await sdk.connectWallet();
      }

      updateStatus('Please approve the transaction in your wallet...');
      const result = await sdk.sendTokens({ recipient, amount, tokenMint });

      updateStatus(
        `Payment successful! View transaction: ${result.explorerUrl}`,
        false,
        true
      );

      const newBalance = await sdk.getTokenBalance(tokenMint);
      updateBalance(newBalance, tokenMint);
    } catch (error) {
      console.error('Payment error:', error);
      updateStatus(`Payment failed: ${error.message}`, true);
    }
  });
}

function populateTokenSelector(sdk) {
  const selector = document.getElementById('tokenSelector');
  if (!selector) return;
  selector.innerHTML = '';
  const tokens = sdk.tokenRegistry.getAllTokens();
  Object.values(tokens).forEach(token => {
    const opt = document.createElement('option');
    opt.value       = token.symbol;
    opt.textContent = `${token.name} (${token.symbol})`;
    selector.appendChild(opt);
  });
}

function updateStatus(message, isError = false, hasLink = false) {
  const statusEl = document.getElementById('statusMessage');
  if (!statusEl) return;
  if (hasLink && message.includes('http')) {
    const parts = message.split(/(https:\/\/[^\s]+)/);
    statusEl.innerHTML = parts.map(part =>
      part.startsWith('https://')
        ? `<a href="${part}" target="_blank" style="color: #0279FF; text-decoration: underline;">${part}</a>`
        : part
    ).join('');
  } else {
    statusEl.textContent = message;
  }
  statusEl.className = isError ? 'status error' : 'status success';
}

function updateBalance(balance, tokenSymbol) {
  const el = document.getElementById('balance');
  if (!el) return;
  el.textContent =
    typeof balance === 'number'
      ? `Balance: ${balance.toFixed(2)} ${tokenSymbol}`
      : `Balance: ${balance} ${tokenSymbol}`;
}
</file>

<file path="examples/simple-payment/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TBallPay SDK – Simple Example</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .container {
      background: #f9f9f9;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
    }
    button {
      background: #512DA8;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
    }
    button:hover {
      background: #673AB7;
    }
    .input-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .status {
      margin-top: 20px;
      padding: 10px;
      border-radius: 4px;
    }
    .success {
      background: #E8F5E9;
      color: #2E7D32;
    }
    .error {
      background: #FFEBEE;
      color: #C62828;
    }
    #tokenSelector {
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <h1>TBallPay SDK Example</h1>

  <div class="container">
    <h2>Wallet</h2>
    <div>
      <button id="connectWallet">Connect Wallet</button>
      <button id="disconnectWallet">Disconnect</button>
    </div>
    <div id="walletInfo">Not connected</div>
    <div id="balance">Balance: 0 TBALL</div>
  </div>

  <div class="container">
    <h2>Send Payment</h2>

    <div class="input-group">
      <label for="tokenSelector">Token:</label>
      <select id="tokenSelector">
        <option value="TBALL">TBALL</option>
      </select>
    </div>

    <div class="input-group">
      <label for="recipient">Recipient Address:</label>
      <input type="text" id="recipient" placeholder="Solana address" />
    </div>

    <div class="input-group">
      <label for="amount">Amount:</label>
      <input type="number" id="amount" placeholder="Amount" step="0.01" min="0" max="1000" />
    </div>

    <button id="sendPayment">Send Payment</button>

    <div id="statusMessage" class="status">Please connect your wallet and fill in the payment details.</div>
  </div>

  <!-- Load dependencies -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
  <script src="https://unpkg.com/bn.js@5.2.1/lib/bn.js"></script>
  <script>
    window.BN = BN;
  </script>

  <!-- Load the UMD bundle of your renamed SDK -->
  <script src="../../dist/tball-pay-sdk.umd.js"></script>

  <!-- Load the example app -->
  <script src="app.js"></script>
</body>
</html>
</file>

<file path="src/core/PaymentProcessor.js">
// src/core/PaymentProcessor.js
import { Connection, PublicKey, Transaction } from '@solana/web3.js';
import { TokenRegistry } from '../token/TokenRegistry';
import { findAssociatedTokenAccount, createAssociatedTokenAccountInstruction, createTransferInstruction } from '../utils/transaction';
import { isValidSolanaAddress } from '../utils/validation';

/**
 * Core Payment Processor for Solana token payments
 */
class PaymentProcessor {
  /**
   * Create a new payment processor
   * @param {Object} config - Configuration options
   */
  constructor(config = {}) {
    this.config = {
      network: config.network || 'mainnet-beta',
      rpcEndpoint: config.rpcEndpoint || null,
      commitment: config.commitment || 'processed',
      confirmationBlocks: config.confirmationBlocks || 32,
      transactionTimeout: config.transactionTimeout || 90000,
      retryAttempts: config.retryAttempts || 5,
      ...config
    };
    
    this.wallet = null;
    this.connection = null;
    this.walletAdapter = null;
    this.tokenRegistry = new TokenRegistry();
    this.initialized = false;
  }
  
  /**
   * Initialize the payment processor
   * @returns {Promise<boolean>} - True if initialization was successful
   */
  async init() {
    try {
      if (this.initialized) return true;
      
      console.log('Initializing payment processor...');
      
      // Get RPC endpoint (from config or fetch from server)
      if (!this.config.rpcEndpoint) {
        const response = await fetch('/api/get-key');
        const data = await response.json();
        this.config.rpcEndpoint = `https://rpc.helius.xyz/?api-key=${data.apiKey}`;
      }
      
      // Initialize Solana connection
      this.connection = new Connection(this.config.rpcEndpoint, {
        commitment: this.config.commitment,
        wsEndpoint: this.config.rpcEndpoint.replace('https', 'wss'),
        confirmTransactionInitialTimeout: 120000,
      });
      
      this.initialized = true;
      return true;
    } catch (error) {
      console.error('Failed to initialize payment processor:', error);
      throw error;
    }
  }

  /**
   * Set wallet adapter to use for transactions
   * @param {Object} adapter - Wallet adapter
   */
  setWalletAdapter(adapter) {
    this.walletAdapter = adapter;
  }
  
  /**
   * Connect to wallet
   * @param {Object} options - Connection options
   * @returns {Promise<Object>} - Wallet account info
   */
  async connectWallet(options = {}) {
    try {
      await this.init();
      
      if (!this.walletAdapter) {
        throw new Error('No wallet adapter set. Call setWalletAdapter() first.');
      }
      
      const walletAccount = await this.walletAdapter.connect(options);
      this.wallet = walletAccount;
      return walletAccount;
    } catch (error) {
      console.error('Wallet connection error:', error);
      throw error;
    }
  }
  
  /**
   * Disconnect wallet
   * @returns {Promise<boolean>} - True if disconnection was successful
   */
  async disconnectWallet() {
    try {
      if (!this.walletAdapter) {
        throw new Error('No wallet adapter set');
      }
      
      await this.walletAdapter.disconnect();
      this.wallet = null;
      return true;
    } catch (error) {
      console.error('Wallet disconnection error:', error);
      throw error;
    }
  }
  
  /**
   * Get token balance
   * @param {string} tokenIdentifier - Token symbol or mint address
   * @returns {Promise<number>} - Token balance
   */
  async getTokenBalance(tokenIdentifier) {
    try {
      if (!this.wallet) throw new Error('Wallet not connected');
      
      const tokenInfo = this.tokenRegistry.getToken(tokenIdentifier);
      if (!tokenInfo) throw new Error(`Unknown token: ${tokenIdentifier}`);
      
      return await this.walletAdapter.getTokenBalance(
        this.connection, 
        this.wallet.publicKey, 
        tokenInfo.mintAddress
      );
    } catch (error) {
      console.error('Error getting token balance:', error);
      throw error;
    }
  }
  
  /**
   * Send tokens
   * @param {Object} params - Payment parameters
   * @param {string} params.recipient - Recipient address
   * @param {number} params.amount - Amount to send
   * @param {string} params.tokenMint - Token identifier (symbol or mint address)
   * @param {string} [params.memo] - Optional memo to include
   * @returns {Promise<Object>} - Transaction result
   */
  async sendTokens(params) {
    try {
      const { recipient, amount, tokenMint, memo } = params;
      
      if (!this.wallet) throw new Error('Wallet not connected');
      if (!this.walletAdapter) throw new Error('No wallet adapter set');
      
      // Validate inputs
      if (!recipient || !isValidSolanaAddress(recipient)) {
        throw new Error('Invalid recipient address');
      }
      
      const tokenInfo = this.tokenRegistry.getToken(tokenMint);
      if (!tokenInfo) throw new Error(`Unknown token: ${tokenMint}`);
      
      if (isNaN(amount) || amount <= 0 || amount > tokenInfo.maxTransferAmount) {
        throw new Error(`Amount must be between 0 and ${tokenInfo.maxTransferAmount} ${tokenInfo.symbol}`);
      }
      
      // Create and send transaction
      const transaction = await this.createTokenTransferTransaction({
        recipient,
        amount,
        tokenMint,
        memo
      });
      
      // Simulate transaction first
      const simulation = await this.connection.simulateTransaction(transaction);
      if (simulation.value.err) {
        throw new Error(`Transaction simulation failed: ${JSON.stringify(simulation.value.err)}`);
      }
      
      // Sign and send transaction
      const signature = await this.walletAdapter.signAndSendTransaction(transaction);
      
      // Confirm transaction
      const confirmation = await this.waitForConfirmation(signature);
      
      return {
        signature,
        confirmation,
        explorerUrl: `https://solscan.io/tx/${signature}`
      };
    } catch (error) {
      console.error('Payment error:', error);
      throw error;
    }
  }
  
  /**
   * Create token transfer transaction
   * @param {Object} params - Transfer parameters
   * @returns {Promise<Transaction>} - Prepared transaction
   * @private
   */
  async createTokenTransferTransaction(params) {
    const { recipient, amount, tokenMint, memo } = params;
    
    const recipientPubKey = new PublicKey(recipient);
    const tokenInfo = this.tokenRegistry.getToken(tokenMint);
    const mintPubKey = new PublicKey(tokenInfo.mintAddress);
    
    // Calculate token amount with decimals
    const transferAmount = Math.floor(amount * Math.pow(10, tokenInfo.decimals));
    
    // Get associated token accounts
    const senderTokenAccount = await findAssociatedTokenAccount(
      this.wallet.publicKey,
      mintPubKey
    );
    
    const recipientTokenAccount = await findAssociatedTokenAccount(
      recipientPubKey,
      mintPubKey
    );
    
    // Initialize transaction
    let transaction = new Transaction();
    
    // Check if recipient token account exists and create if needed
    const recipientAccountInfo = await this.connection.getAccountInfo(recipientTokenAccount);
    if (!recipientAccountInfo) {
      transaction.add(
        createAssociatedTokenAccountInstruction(
          this.wallet.publicKey,
          recipientPubKey,
          mintPubKey
        )
      );
    }
    
    // Add transfer instruction
    transaction.add(
      createTransferInstruction(
        senderTokenAccount,
        recipientTokenAccount,
        this.wallet.publicKey,
        transferAmount
      )
    );
    
    // Add memo if provided
    if (memo) {
      // Memo instruction logic would go here
    }
    
    // Get recent blockhash
    const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed');
    transaction.recentBlockhash = blockhash;
    transaction.lastValidBlockHeight = lastValidBlockHeight;
    transaction.feePayer = this.wallet.publicKey;
    
    return transaction;
  }
  
  /**
   * Wait for transaction confirmation
   * @param {string} signature - Transaction signature
   * @returns {Promise<Object>} - Confirmation status
   * @private
   */
  async waitForConfirmation(signature) {
    let timeoutId;
    let intervalId;
    let attempt = 0;

    const confirmationPromise = new Promise(async (resolve, reject) => {
      const timeout = () => {
        clearInterval(intervalId);
        reject(new Error('Transaction confirmation timeout'));
      };

      const checkConfirmation = async () => {
        console.log(`Checking confirmation attempt ${attempt + 1}/${this.config.retryAttempts}`);
        
        try {
          const status = await this.connection.getSignatureStatus(signature);
          console.log('Transaction status:', status?.value?.confirmationStatus);
          
          if (!status?.value) {
            if (attempt >= this.config.retryAttempts) {
              clearInterval(intervalId);
              clearTimeout(timeoutId);
              resolve({ 
                status: 'pending', 
                signature, 
                explorerUrl: `https://solscan.io/tx/${signature}`
              });
              return;
            }
          } else {
            const confirmations = status.value.confirmations;

            if (status.value.err) {
              clearInterval(intervalId);
              clearTimeout(timeoutId);
              reject(new Error('Transaction failed on chain'));
              return;
            }

            if (confirmations >= this.config.confirmationBlocks || 
                status.value.confirmationStatus === 'finalized') {
              clearInterval(intervalId);
              clearTimeout(timeoutId);
              resolve(status);
              return;
            }
          }
          
          attempt++;
        } catch (err) {
          console.warn('Confirmation check failed:', err);
          attempt++;
        }
      };

      timeoutId = setTimeout(timeout, this.config.transactionTimeout);
      intervalId = setInterval(checkConfirmation, 2000);
      await checkConfirmation(); // Check immediately
    });

    return confirmationPromise;
  }
}

export { PaymentProcessor };
</file>

<file path="src/token/TokenRegistry.js">
// src/token/TokenRegistry.js

/**
 * Registry for managing supported tokens
 */
class TokenRegistry {
    constructor() {
      this.tokens = {
        // Default tokens
        'TBALL': {
          name: 'Tetherball',
          symbol: 'TBALL',
          mintAddress: 'CWnzqQVFaD7sKsZyh116viC48G7qLz8pa5WhFpBEg9wM',
          decimals: 9,
          maxTransferAmount: 1000,
          logoUrl: 'https://example.com/tball-logo.png'
        }
        // Additional tokens can be added here
      };
    }
    
    /**
     * Get token by symbol or mint address
     * @param {string} tokenIdentifier - Token symbol or mint address
     * @returns {Object|null} - Token info or null if not found
     */
    getToken(tokenIdentifier) {
      // Check if direct lookup by token symbol works
      if (this.tokens[tokenIdentifier]) {
        return this.tokens[tokenIdentifier];
      }
      
      // Otherwise search by mint address
      return Object.values(this.tokens).find(
        token => token.mintAddress === tokenIdentifier
      ) || null;
    }
    
    /**
     * Add a new token to the registry
     * @param {Object} tokenInfo - Token information
     * @returns {Object} - Added token info
     */
    addToken(tokenInfo) {
      if (!tokenInfo.symbol || !tokenInfo.mintAddress) {
        throw new Error('Token must have symbol and mintAddress');
      }
      
      this.tokens[tokenInfo.symbol] = {
        name: tokenInfo.name || tokenInfo.symbol,
        symbol: tokenInfo.symbol,
        mintAddress: tokenInfo.mintAddress,
        decimals: tokenInfo.decimals || 9,
        maxTransferAmount: tokenInfo.maxTransferAmount || 1000,
        logoUrl: tokenInfo.logoUrl || null
      };
      
      return this.tokens[tokenInfo.symbol];
    }
    
    /**
     * Get all tokens in the registry
     * @returns {Object} - All tokens
     */
    getAllTokens() {
      return this.tokens;
    }
    
    /**
     * Remove a token from the registry
     * @param {string} symbol - Token symbol
     * @returns {boolean} - True if token was removed
     */
    removeToken(symbol) {
      if (this.tokens[symbol]) {
        delete this.tokens[symbol];
        return true;
      }
      return false;
    }
  }
  
  export { TokenRegistry };
</file>

<file path="src/utils/transaction.js">
// src/utils/transaction.js
import { PublicKey, SystemProgram, TransactionInstruction } from '@solana/web3.js';
import BN from 'bn.js';

// Constants
const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');

/**
 * Find the associated token account address
 * @param {PublicKey} owner - Account owner
 * @param {PublicKey} mint - Token mint address
 * @returns {Promise<PublicKey>} - Associated token account address
 */
export async function findAssociatedTokenAccount(owner, mint) {
  return PublicKey.findProgramAddressSync(
    [
      owner.toBuffer(),
      TOKEN_PROGRAM_ID.toBuffer(),
      mint.toBuffer(),
    ],
    ASSOCIATED_TOKEN_PROGRAM_ID
  )[0];
}

/**
 * Create instruction to create an associated token account
 * @param {PublicKey} payer - Fee payer
 * @param {PublicKey} owner - Account owner
 * @param {PublicKey} mint - Token mint
 * @returns {TransactionInstruction} - Transaction instruction
 */
export function createAssociatedTokenAccountInstruction(payer, owner, mint) {
  return new TransactionInstruction({
    keys: [
      { pubkey: payer, isSigner: true, isWritable: true },
      { pubkey: findAssociatedTokenAccount(owner, mint), isSigner: false, isWritable: true },
      { pubkey: owner, isSigner: false, isWritable: false },
      { pubkey: mint, isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    ],
    programId: ASSOCIATED_TOKEN_PROGRAM_ID,
    data: Buffer.from([]),
  });
}

/**
 * Create instruction to transfer tokens
 * @param {PublicKey} source - Source account
 * @param {PublicKey} destination - Destination account
 * @param {PublicKey} owner - Token owner
 * @param {number} amount - Amount to transfer (in raw units)
 * @returns {TransactionInstruction} - Transaction instruction
 */
export function createTransferInstruction(source, destination, owner, amount) {
  return new TransactionInstruction({
    keys: [
      { pubkey: source, isSigner: false, isWritable: true },
      { pubkey: destination, isSigner: false, isWritable: true },
      { pubkey: owner, isSigner: true, isWritable: false },
    ],
    programId: TOKEN_PROGRAM_ID,
    data: Buffer.from([3, ...new BN(amount).toArray('le', 8)]), // 3 is the instruction index for transfer
  });
}
</file>

<file path="src/utils/validation.js">
// src/utils/validation.js
import { PublicKey } from '@solana/web3.js';

/**
 * Check if a string is a valid Solana address
 * @param {string} address - Address to validate
 * @returns {boolean} - True if address is valid
 */
export function isValidSolanaAddress(address) {
  try {
    new PublicKey(address);
    return true;
  } catch {
    return false;
  }
}

/**
 * Validate payment parameters
 * @param {Object} params - Payment parameters
 * @param {string} params.recipient - Recipient address
 * @param {number} params.amount - Amount to send
 * @param {Object} tokenInfo - Token information
 * @returns {Object} - Validation result {isValid, error}
 */
export function validatePaymentParams(params, tokenInfo) {
  const { recipient, amount } = params;
  
  if (!recipient || !isValidSolanaAddress(recipient)) {
    return {
      isValid: false,
      error: 'Invalid recipient address'
    };
  }
  
  if (!tokenInfo) {
    return {
      isValid: false,
      error: 'Invalid token'
    };
  }
  
  if (isNaN(amount) || amount <= 0) {
    return {
      isValid: false,
      error: 'Amount must be greater than 0'
    };
  }
  
  if (tokenInfo.maxTransferAmount && amount > tokenInfo.maxTransferAmount) {
    return {
      isValid: false,
      error: `Amount exceeds maximum transfer amount of ${tokenInfo.maxTransferAmount} ${tokenInfo.symbol}`
    };
  }
  
  return {
    isValid: true,
    error: null
  };
}
</file>

<file path="src/wallet/PhantomAdapter.js">
// src/wallet/PhantomAdapter.js
import { PublicKey } from '@solana/web3.js';

/**
 * Wallet adapter for Phantom wallet
 */
class PhantomAdapter {
  constructor() {
    this.wallet = null;
  }
  
  /**
   * Check if wallet is available
   * @returns {Promise<boolean>} - True if wallet is available
   */
  async checkAvailability() {
    if (!window.solana || !window.solana.isPhantom) {
      throw new Error('Phantom Wallet not detected. Please install it from https://phantom.app/');
    }
    return true;
  }
  
  /**
   * Connect to wallet
   * @param {Object} options - Connection options
   * @returns {Promise<Object>} - Wallet account info
   */
  async connect(options = {}) {
    try {
      await this.checkAvailability();
      
      // Disconnect existing connection if any
      try {
        await window.solana.disconnect();
      } catch (err) {
        console.log('No existing connection to disconnect');
      }
      
      // Connect with options
      const connectOptions = {
        onlyIfTrusted: false,
        forceReapproval: true, // Always force user to re-approve
        ...options
      };
      
      const response = await window.solana.connect(connectOptions);
      this.wallet = {
        publicKey: new PublicKey(response.publicKey.toString())
      };
      
      return this.wallet;
    } catch (error) {
      if (error.message.includes('User rejected')) {
        throw new Error('Connection rejected by user');
      }
      throw error;
    }
  }
  
  /**
   * Disconnect from wallet
   * @returns {Promise<boolean>} - True if disconnection was successful
   */
  async disconnect() {
    try {
      await window.solana.disconnect();
      this.wallet = null;
      return true;
    } catch (error) {
      throw error;
    }
  }
  
  /**
   * Get token balance
   * @param {Connection} connection - Solana connection
   * @param {PublicKey} owner - Token owner
   * @param {string} mintAddress - Token mint address
   * @returns {Promise<number>} - Token balance
   */
  async getTokenBalance(connection, owner, mintAddress) {
    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
      owner,
      { mint: new PublicKey(mintAddress) }
    );
    
    if (tokenAccounts.value.length > 0) {
      return tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;
    }
    
    return 0;
  }
  
  /**
   * Sign and send transaction
   * @param {Transaction} transaction - Transaction to sign and send
   * @returns {Promise<string>} - Transaction signature
   */
  async signAndSendTransaction(transaction) {
    try {
      const opts = {
        skipPreflight: false,
        preflightCommitment: 'processed',
        maxRetries: 5
      };
      
      const signed = await window.solana.signAndSendTransaction(transaction, opts);
      return signed.signature;
    } catch (error) {
      if (error.message.includes('User rejected')) {
        throw new Error('Transaction was rejected by user');
      }
      throw error;
    }
  }
}

export { PhantomAdapter };
</file>

<file path="src/index.js">
// src/index.js
import { PaymentProcessor } from './core/PaymentProcessor';
import { PhantomAdapter } from './wallet/PhantomAdapter';
import { TokenRegistry } from './token/TokenRegistry';
import * as TransactionUtils from './utils/transaction';
import * as ValidationUtils from './utils/validation';

// Export all components
export {
  PaymentProcessor,
  PhantomAdapter,
  TokenRegistry,
  TransactionUtils,
  ValidationUtils
};

// Default export for easier importing
export default {
  PaymentProcessor,
  PhantomAdapter,
  TokenRegistry,
  TransactionUtils,
  ValidationUtils
};

// Helper function to create a pre-configured SDK instance
export function createSolanaPaymentSDK(config = {}) {
  const processor = new PaymentProcessor(config);
  const phantomAdapter = new PhantomAdapter();
  
  // Set up the wallet adapter
  processor.setWalletAdapter(phantomAdapter);
  
  return {
    processor,
    phantomAdapter,
    tokenRegistry: processor.tokenRegistry,
    
    // Initialize everything
    async init() {
      await processor.init();
      return this;
    }
  };
}
</file>

<file path=".gitignore">
node_modules/
.env
</file>

<file path="package.json">
{
  "name": "tball-pay-sdk",
  "version": "1.0.0",
  "description": "Lightweight JavaScript SDK for TBALL token payments on the Solana blockchain",
  "keywords": [
    "solana",
    "payments",
    "sdk",
    "tball",
    "spl-token",
    "phantom"
  ],
  "author": "Zack Adams",
  "license": "MIT",
  "main": "dist/tball-pay-sdk.umd.js",
  "module": "dist/tball-pay-sdk.esm.js",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "webpack --mode=production",
    "build:dev": "webpack --mode=development",
    "dev": "webpack --mode=development --watch",
    "serve": "node server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/your-username/tball-pay-sdk.git"
  },
  "bugs": {
    "url": "https://github.com/your-username/tball-pay-sdk/issues"
  },
  "homepage": "https://github.com/your-username/tball-pay-sdk#readme",
  "dependencies": {
    "@solana/web3.js": "^1.98.0",
    "bn.js": "^5.2.1",
    "buffer": "^6.0.3",
    "dotenv": "^16.4.7",
    "express": "^4.21.2"
  },
  "devDependencies": {
    "@babel/core": "^7.26.10",
    "@babel/preset-env": "^7.26.9",
    "babel-loader": "^10.0.0",
    "webpack": "^5.98.0",
    "webpack-cli": "^6.0.1"
  },
  "exports": {
    ".": {
      "import": "./dist/tball-pay-sdk.esm.js",
      "require": "./dist/tball-pay-sdk.umd.js"
    }
  }
}
</file>

<file path="README.md">
# 🏐 Solana Payments SDK

A lightweight JavaScript SDK to power custom token payments on the Solana blockchain. Easily connect Phantom, manage balances, and send SPL tokens (like $TBALL) from any browser app — no smart contracts or backend required.

## 🚀 Features

- 🔐 Phantom wallet integration (connect/disconnect)
- 🪙 Send SPL tokens (e.g. TBALL) between wallets
- 🧠 Token registry with built-in metadata
- ✅ Input validation and transaction simulation
- 🔄 Real-time balance fetching
- 📦 Bundled for browser or module-based usage

## 📦 Installation

### Option 1: Import UMD bundle in browser (no build step)

```html
<script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
<script src="https://unpkg.com/bn.js@5.2.1/lib/bn.js"></script>
<script src="./dist/solana-payments-sdk.js"></script>
```

### Option 2: Install via npm

```bash
npm install solana-payments-sdk
```

## 🧪 Example (Browser App)

### index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Solana Payments SDK Example</title>
</head>
<body>
  <h1>Solana Payments SDK</h1>
  <button id="connectWallet">Connect Wallet</button>
  <button id="sendPayment">Send 5 TBALL</button>
  <div id="statusMessage"></div>
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
  <script src="https://unpkg.com/bn.js@5.2.1/lib/bn.js"></script>
  <script>
    window.BN = BN;
  </script>
  <script src="./dist/solana-payments-sdk.js"></script>
  <script>
    const { PaymentProcessor, PhantomAdapter } = SolanaPaymentsSDK;
    const processor = new PaymentProcessor({ network: 'mainnet-beta' });
    processor.setWalletAdapter(new PhantomAdapter());
    document.getElementById('connectWallet').onclick = async () => {
      await processor.init();
      await processor.connectWallet();
      alert('Wallet connected!');
    };
    document.getElementById('sendPayment').onclick = async () => {
      const result = await processor.sendTokens({
        recipient: 'EnterRecipientPublicKeyHere',
        amount: 5,
        tokenMint: 'TBALL'
      });
      document.getElementById('statusMessage').innerHTML =
        `Payment sent! <a href="${result.explorerUrl}" target="_blank">View on Solscan</a>`;
    };
  </script>
</body>
</html>
```

## ⚙️ API Overview

### PaymentProcessor(config)
- `network`: Solana cluster (e.g. 'mainnet-beta')
- `rpcEndpoint`: Optional custom RPC endpoint

#### Methods
- `init()` – Initialize SDK and Solana connection
- `setWalletAdapter(adapter)` – Attach a wallet adapter
- `connectWallet()` – Prompt Phantom to connect
- `disconnectWallet()` – Disconnect the wallet
- `getTokenBalance(tokenSymbolOrMint)` – Get the wallet's token balance
- `sendTokens({ recipient, amount, tokenMint })` – Send SPL tokens

### PhantomAdapter()
Adapter for Phantom Wallet. Required for connecting and signing.

### TokenRegistry
Manage supported tokens and metadata.

```javascript
const registry = new TokenRegistry();
registry.addToken({
  symbol: 'DOGE',
  mintAddress: 'YourTokenMintAddressHere',
  decimals: 9,
  maxTransferAmount: 100000
});
```

## 📁 Project Structure

```
solana-payments-sdk/
├── dist/                      # Bundled SDK (UMD)
├── examples/simple-payment/   # Full demo: index.html + app.js
├── src/
│   ├── core/PaymentProcessor.js
│   ├── wallet/PhantomAdapter.js
│   ├── token/TokenRegistry.js
│   └── utils/
│       ├── transaction.js
│       └── validation.js
├── webpack.config.js
└── package.json
```

## 🛡️ Security & Best Practices

- Always simulate and confirm transactions before marking them complete
- Validate addresses with `isValidSolanaAddress()` before sending
- Never hardcode private keys or RPC endpoints client-side
- Always check balances and limits before sending transactions

## 🧠 TODOs & Roadmap

- [ ] Add support for TransferChecked instruction
- [ ] Support other wallets (e.g. Solflare, Backpack)
- [ ] React/Vue wrappers
- [ ] Token swap & NFT utilities
- [ ] Add TypeScript types

## 👨‍🍳 Created by Zack Adams

Built for memecoins, games, marketplaces, and crypto-native experiences.
Let the blockchain be your backend.

## 🧵 Feedback / Issues

Open a GitHub issue or contact @hackingbaseball on Twitter.
</file>

<file path="server.js">
require('dotenv').config();
const express = require('express');
const path = require('path');
const app = express();

// Serve static files
app.use(express.static('examples/simple-payment'));
app.use('/dist', express.static('dist'));

// API endpoint for Helius key
app.get('/api/get-key', (req, res) => {
  res.json({ apiKey: process.env.HELIUS_KEY });
});

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Server running at http://localhost:${PORT}`);
});
</file>

<file path="webpack.config.js">
// webpack.config.js

const path = require('path');
const webpack = require('webpack');

module.exports = {
  // Entry point for your SDK
  entry: './src/index.js',

  // Output configuration
  output: {
    // Directory to emit bundled files
    path: path.resolve(__dirname, 'dist'),

    // UMD bundle for browsers and Node
    filename: 'tball-pay-sdk.umd.js',

    // Name of the global variable when included via <script>
    library: 'TBallPaySDK',

    // Export in UMD format (AMD, CommonJS, global)
    libraryTarget: 'umd',

    // Ensures the globalObject is correct in different environments
    globalObject: 'this',

    // Name the AMD module (optional, but conventional)
    umdNamedDefine: true
  },

  // Production mode for optimizations; use 'development' for faster builds
  mode: 'production',

  // Generate source maps for debugging
  devtool: 'source-map',

  module: {
    rules: [
      {
        // Transpile JS with Babel
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env', {
                // Targets can be customized as needed
                targets: "> 0.25%, not dead"
              }]
            ]
          }
        }
      }
    ]
  },

  resolve: {
    // Allow omitting extensions when importing
    extensions: ['.js'],

    // Fallbacks for Node built-ins (e.g., Buffer)
    fallback: {
      buffer: require.resolve('buffer/')
    }
  },

  plugins: [
    // Provide Buffer automatically without import
    new webpack.ProvidePlugin({
      Buffer: ['buffer', 'Buffer']
    })
  ],

  // Don't bundle these dependencies; expect them as externals
  externals: {
    '@solana/web3.js': 'solanaWeb3',
    'bn.js': 'BN'
  }
};
</file>

</files>
